  
  #############
  # Debugging #
  #############

  Currently, we have a major issue: untrusted code cannot read or write into SRAM. The behaviour is RAZ and WI, but not exception is raised.
  Not even by using debugger I can write. The debugger notifies an error when trying to write or read secure memory, but it does not
  when accessing Non secure regions, though writes does not happen anyway.
  I can correctly read in system memory (e.g. MPU registers). Even by enabling the MPU (with background region) I cannot still write/read.

  Secure region definitions is somehow buggy. In fact, all Non-secure regions defined in the secureboot start
  32 bytes after (e.g. 0x08040000 -> 0x08040020 and 0x20000000 -> 0x20000020). 
  This is probably a minor bug either in the SAU driver implementation or in the MemoryGuard stuff.
  
  
  ############################################################################################################


  ##########
  # Linker #
  ##########

  Linker script must be built hiearchically. This is required since Umbra, as a library, will be placed in a fixed memory region depending on the target platform.
  The platform linker script will define the secure boot region and the umbra kernel region. The kernel linker script will be used by the host as well as we must
  ensure umbra to share the same position for both the host and the secure boot. The idea is to have two separate elf, both including umbra sections. If they are
  overlapped, it is possible to load both elf in memory and having a consistent behaviour (allowing for the host to be independent from the boot code).
  Note that drivers are included in the secure boot elf, and not in the umbra kernel.

  As a structure, depending on the settings.sh, the platform.ld must include umbra.ld. The host.ld will also include umbra.ld
  We need both platform and umbra to reuse host defined memory blocks. To ease such a process, we assume the host to use the names
  that Umbra needs.

  Also, we need to include envvar in linker script

  NB: Major refactoring will be required

  ##############
  # Toml files #
  ##############

  The config.toml should be a common file among different projects. Similarly to the linker script, a hierarchy of config.toml should exists (if doable).
  There are multiple ways to do so, but a choice could be to have a top-level config.toml that includes a config.toml for the architecture and for the platform.
  (including flags and compilers). architecture and platform can be passed to the settings.sh script. In addition to this, redefine CARGO envvar with settings.sh
   
  Currently, there is a Makefile in the boot project. It can be fine, but we need a top-level Makefile that, depending on the settings.sh configuration,
  will build (a) the Kernel library and (b) the boot binary for the specific combination {architecture, platform}.

  ############
  # Compiler #
  ############

  Problems with linking the liberknel.a. First, the library is quite bloated (5MB in .a and 41KB in .rlib). 
  I am not entirely sure why this happens; must investigate further. A key observation is that rustc backend is llvm, and can use
  3 profiles for armv8:
    - target.thumbv8m.base-none-eabi
    - target.thumbv8m.main-none-eabi
    - target.thumbv8m.main-none-eabihf
  when compiling the host code, be sure to use the correct -march flag (e.g. -march=armv8-m.main).

  ##########
  # Envvar #
  ##########

    -- Compiler target
    -- Selected Platform (therefore, linkerscript structure)
    -- At the moment some envvar are hardcoded to my absolute path

  ################
  # Dependencies #
  ################

  rust alone is not enough. Currently, we are using nightly instead of stable.
  Therefore users are required to:
    -- rustup toolchain install nightly
    -- rustup override set nightly
    -- rustup target add thumbv8m.main-none-eabi